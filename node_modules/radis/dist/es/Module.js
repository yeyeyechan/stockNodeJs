import * as tslib_1 from "tslib";
import { Injector } from './Injector';
import { isInjectable, isFunction, isServiceName, serviceNameRegex } from './utils';
var Module = /** @class */ (function () {
    /**
     * @param name The name of ne module
     * @param dependencies An array of dependencies modules
     */
    function Module(name, dependencies) {
        this.name = name;
        this.dependencies = dependencies;
        this.services = {};
        this.configHooks = [];
        this.runHooks = [];
    }
    /**
     * @returns The module name
     */
    Module.prototype.getName = function () {
        return this.name;
    };
    /**
     * @param injectable A config hook function
     * @returns The current module
     */
    Module.prototype.config = function (injectable) {
        if (!isInjectable(injectable)) {
            throw new Error("Can't register config injectable " + injectable + " in " + this.getName());
        }
        this.configHooks.push(injectable);
        return this;
    };
    /**
     * @param {Injectable} injectable A run hook function
     * @returns {Module} The current module
     */
    Module.prototype.run = function (injectable) {
        if (!isInjectable(injectable)) {
            throw new Error("Can't register run injectable " + injectable + " in " + this.getName());
        }
        this.runHooks.push(injectable);
        return this;
    };
    /**
     * Register a new service in the module
     * @param serviceName the service name
     * @param serviceClass The service class
     * @returns this
     */
    Module.prototype.service = function (serviceName, serviceClass) {
        if (!isServiceName(serviceName)) {
            throw new Error("Can't register service in " + this.getName() + " with name " + serviceName + ". serviceName must match " + serviceNameRegex);
        }
        if (!isFunction(serviceClass)) {
            throw new Error("Can't register service in " + this.getName() + " with name " + serviceName + ". Invalid serviceClass " + serviceClass);
        }
        this.services[serviceName] = /** @class */ (function () {
            function class_1() {
            }
            class_1.prototype.$get = function ($injector) {
                return $injector.instantiate(serviceClass, { $name: serviceName });
            };
            return class_1;
        }());
        return this;
    };
    /**
     * Register a new service in the module by providing a factory
     * @param serviceName the name of the service
     * @param injectable The function responsible of creating the service instance.
     * @returns this
     */
    Module.prototype.factory = function (serviceName, injectable) {
        if (!isServiceName(serviceName)) {
            throw new Error("Can't register factory in " + this.getName() + " with name " + serviceName + ". serviceName must match " + serviceNameRegex);
        }
        if (!isInjectable(injectable)) {
            throw new Error("Can't register factory in " + this.getName() + " with name " + serviceName + ". Invalid injectable " + injectable);
        }
        this.services[serviceName] = /** @class */ (function () {
            function class_2() {
            }
            class_2.prototype.$get = function ($injector) {
                return $injector.invoke(injectable, $injector, { $name: serviceName });
            };
            return class_2;
        }());
        return this;
    };
    /**
     * Register a new service in the module by providing a provider class
     * @param serviceName The service name
     * @param providerClass A provider constructor
     * @returns this
     */
    Module.prototype.provider = function (serviceName, providerClass) {
        if (!isServiceName(serviceName)) {
            throw new Error("Can't register provider in " + this.getName() + " with name " + serviceName + ". serviceName must match " + serviceNameRegex);
        }
        if (!isFunction(providerClass)) {
            throw new Error("Can't register provider in " + this.getName() + " with name " + serviceName + ". Invalid providerClass " + providerClass);
        }
        this.services[serviceName] = providerClass;
        return this;
    };
    /**
     * Bootstrap the module
     * @return The module injector
     */
    Module.prototype.bootstrap = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var modules, $injectors, $injector, i, module_1, j, hook, i, module_2, j, hook;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        modules = [];
                        $injectors = [];
                        $injector = this._bootstrap(modules, $injectors);
                        modules.push(this);
                        $injectors.push($injector);
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(modules.length > i)) return [3 /*break*/, 6];
                        module_1 = modules[i];
                        j = 0;
                        _a.label = 2;
                    case 2:
                        if (!(module_1.configHooks.length > j)) return [3 /*break*/, 5];
                        hook = module_1.configHooks[j];
                        return [4 /*yield*/, $injectors[i].invoke(hook)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        j++;
                        return [3 /*break*/, 2];
                    case 5:
                        i++;
                        return [3 /*break*/, 1];
                    case 6:
                        i = 0;
                        _a.label = 7;
                    case 7:
                        if (!(modules.length > i)) return [3 /*break*/, 12];
                        module_2 = modules[i];
                        j = 0;
                        _a.label = 8;
                    case 8:
                        if (!(module_2.runHooks.length > j)) return [3 /*break*/, 11];
                        hook = module_2.runHooks[j];
                        return [4 /*yield*/, $injectors[i].invoke(hook)];
                    case 9:
                        _a.sent();
                        _a.label = 10;
                    case 10:
                        j++;
                        return [3 /*break*/, 8];
                    case 11:
                        i++;
                        return [3 /*break*/, 7];
                    case 12: return [2 /*return*/, $injector];
                }
            });
        });
    };
    /**
     * Bootstrap the module.
     * @param modules An array of module
     * @param $injectors An array of corresponding injector
     * @returns the newly created injector
     */
    Module.prototype._bootstrap = function (modules, $injectors) {
        var _this = this;
        var $injector = new Injector();
        Object.keys(this.services).forEach(function (serviceName) { return $injector.addProvider(serviceName, _this.services[serviceName]); });
        this.dependencies.forEach(function (dependency) {
            var moduleIndex = modules.indexOf(dependency);
            if (moduleIndex === -1) {
                $injectors.push(dependency._bootstrap(modules, $injectors));
                modules.push(dependency);
                moduleIndex = modules.length - 1;
            }
            $injector.addChild($injectors[moduleIndex]);
        });
        return $injector;
    };
    return Module;
}());
export { Module };
//# sourceMappingURL=Module.js.map