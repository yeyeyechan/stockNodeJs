/**
 * The module name RegExp
 */
var moduleNameRegex = /^[a-zA-Z][a-zA-Z0-9]*$/;
/**
 * The service name RegExp
 */
var serviceNameRegex = /^[a-zA-Z][a-zA-Z0-9]*$/;
/**
 * The service method name RegExp
 */
var serviceMethodNameRegex = /^[a-zA-Z_][a-zA-Z0-9_]*:[^:]+$/;
/**
 * Test if value is an array
 * @param value the value you want to test
 * @return True is value is an array
 */
function isArray(value) {
    return Array.isArray(value);
}
/**
 * Test if value is a string
 * @param  value the value you want to test
 * @return true is value is a string
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * Test if value is a function
 * @param  value the value you want to test
 * @return true is value is a function
 */
function isFunction(value) {
    return !!(value && value.constructor && value.call && value.apply);
}
/**
 * Test if value is an Injectable
 * @param  value the value you want to test
 * @return true is value is an injectable
 */
function isInjectable(value) {
    return isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])) || (isString(value) && serviceMethodNameRegex.test(value));
}
/**
 * Test if value is a valid module name
 * @param name the value you want to test
 * @return true is value is a valid module name
 */
function isModuleName(name) {
    return moduleNameRegex.test(name);
}
/**
 * Test if value is a valid service name
 * @param  name the value you want to test
 * @return true is value is a valid service name
 */
function isServiceName(name) {
    return serviceNameRegex.test(name);
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/*!
 * function-arguments <https://github.com/tunnckoCore/function-arguments>
 *
 * Copyright (c) 2016 Charlike Mike Reagent <@tunnckoCore> (http://www.tunnckocore.tk)
 * Released under the MIT license.
 */

/**
 * > Get function arguments names.
 *
 * **Example**
 *
 * ```js
 * var fnArgs = require('function-arguments')
 *
 * console.log(fnArgs(function (a, b, c) {})) // => [ 'a', 'b', 'c' ]
 * console.log(fnArgs(function named (a , b, c) {})) // => [ 'a', 'b', 'c' ]
 *
 * console.log(fnArgs(a => {})) // => [ 'a' ]
 * console.log(fnArgs((a, b) => {})) // => [ 'a', 'b' ]
 *
 * console.log(fnArgs(function * (a ,b, c) {})) // => [ 'a', 'b', 'c' ]
 * console.log(fnArgs(function * named (a ,b, c) {})) // => [ 'a', 'b', 'c' ]
 * ```
 *
 * @param  {Function} `fn` Function from which to get arguments names.
 * @return {Array}
 * @api public
 */

var functionArguments = function functionArguments (fn) {
  if (typeof fn !== 'function') {
    throw new TypeError('function-arguments expect a function')
  }
  if (fn.length === 0) {
    return []
  }

  // from https://github.com/jrburke/requirejs
  var reComments = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
  var fnToStr = Function.prototype.toString;
  var fnStr = fnToStr.call(fn);
  fnStr = fnStr.replace(reComments, '') || fnStr;
  fnStr = fnStr.slice(0, fnStr.indexOf('{'));

  var open = fnStr.indexOf('(');
  var close = fnStr.indexOf(')');

  open = open >= 0 ? open + 1 : 0;
  close = close > 0 ? close : fnStr.indexOf('=');

  fnStr = fnStr.slice(open, close);
  fnStr = '(' + fnStr + ')';

  var match = fnStr.match(/\(([\s\S]*)\)/);
  return match ? match[1].split(',').map(function (param) {
    return param.trim()
  }) : []
};

var ResolvedInjectable = /** @class */ (function () {
    function ResolvedInjectable(func, self, services) {
        this.func = func;
        this.self = self;
        this.services = services;
    }
    ResolvedInjectable.prototype.invoke = function (injector, locals) {
        var services = this.services.map(function (serviceName) { return injector.getService(serviceName, locals); });
        return this.func.apply(this.self, services);
    };
    return ResolvedInjectable;
}());
/**
 *
 */
var Injector = /** @class */ (function () {
    /**
     *
     */
    function Injector() {
        this.services = {};
    }
    /**
     * This method invoke the given injectable applying right parameters based on their name
     * @param injectable A function to be invoked
     * @param self An object to which the injectable function will be bind to
     * @param locals Additional one-time services that will be injected into the injectable
     * @return The return value of injectable
     */
    Injector.prototype.invoke = function (injectable, self, locals) {
        if (self === void 0) { self = null; }
        if (locals === void 0) { locals = {}; }
        return this._resolveInjectable(injectable, self).invoke(this, locals);
    };
    /**
     * Call new operator on the given injectableClass proving the controller with the right parameters.
     * @info injectableClass.$inject MUST be an array
     * @param injectableClass A injectable class
     * @param locals Additional variables that will be injected
     * @returns A new instance of injectableClass
     */
    Injector.prototype.instantiate = function (injectableClass, locals) {
        var _this = this;
        if (locals === void 0) { locals = {}; }
        var serviceNames = injectableClass['$inject'] || [];
        var services = serviceNames.map(function (serviceName) { return _this.getService(serviceName, locals); });
        return new (injectableClass.bind.apply(injectableClass, [void 0].concat(services)))();
    };
    /**
     * This method lift a classic function to an injectable function.
     * @example
     * let middleware = (service1, req, res, nex) => console.log(service1, req, res, next)
     * let liftedMiddleware = $injector.lift(middleware, ["req", "res", "next"]);
     * app.use(liftedMiddleware) OR  liftedMiddleware(req, res, next(
     * @param injectable The function you want to lift
     * @param self An object to which the injectable function will be bind to
     * @param paramNames the name of the parameter lift will received so they can be injected.
     * @param locals Additional variables that will be injected
     * @return {Function} The lifted function
     */
    Injector.prototype.lift = function (injectable, self, paramNames, locals) {
        var _this = this;
        if (self === void 0) { self = null; }
        if (paramNames === void 0) { paramNames = []; }
        if (locals === void 0) { locals = {}; }
        var cache;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // Merge locals and positional params
            var _locals = Object.assign({}, locals);
            paramNames.forEach(function (name, index) {
                _locals[name] = args[index];
            });
            // If injection was already resolve use cached version.
            if (cache) {
                return cache.invoke(_this, _locals);
            }
            cache = _this._resolveInjectable(injectable, self);
            return cache.invoke(_this, _locals);
        };
    };
    /**
     * @param serviceName The name of the service
     * @param locals Additional variables that will be injected
     * @returns The service instance
     * @throws The service must exist
     * @private
     */
    Injector.prototype.getService = function (serviceName, locals) {
        if (locals === void 0) { locals = {}; }
        if (locals[serviceName] !== undefined) {
            return locals[serviceName];
        }
        if (serviceName === '$injector') {
            return this;
        }
        if (serviceName.endsWith('Provider')) {
            return this._getProvider(serviceName.substr(0, serviceName.length - 'Provider'.length));
        }
        var serviceBag = this.services[serviceName];
        if (!serviceBag) {
            throw new Error("Can't load service with name " + serviceName);
        }
        var provider = this._getProvider(serviceName);
        if (serviceBag.service === undefined) {
            serviceBag.service = this.invoke(provider.$get, provider, { $name: serviceName });
            if (serviceBag.service === undefined) {
                throw new Error("Method $get of " + serviceName + " provider must return a valid service got " + serviceBag.service);
            }
        }
        return serviceBag.service;
    };
    /**
     * Add a child injector
     * @param $injector The child injector
     * @return {Injector} this
     */
    Injector.prototype.addChild = function ($injector) {
        this.services = __assign({}, $injector.services, this.services);
        return this;
    };
    Injector.prototype.addProvider = function (serviceName, providerClass) {
        this.services[serviceName] = { providerClass: providerClass };
        return this;
    };
    /**
     * @param serviceName The service name
     * @returns the provider
     * @private
     */
    Injector.prototype._getProvider = function (serviceName) {
        var serviceBag = this.services[serviceName];
        if (!serviceBag) {
            throw new Error("Can't load service with name " + serviceName);
        }
        if (serviceBag.provider === undefined) {
            serviceBag.provider = new serviceBag.providerClass(this, serviceName);
        }
        return serviceBag.provider;
    };
    Injector.prototype._resolveFunctionInjectable = function (injectable, self) {
        var services = functionArguments(injectable);
        /*
           * Handle single param arrow function without params with one line return
           * eg: v => true
           * https://github.com/charlike/function-arguments/issues/2
           */
        if (services.length === 1 && services[0] === '') {
            var funcStr = injectable.toString();
            var params = funcStr.replace(/\s/gm, '').split('=>');
            if (params.length < 2)
                throw new Error("Can't parse params for function ${params}");
            services = [params[0]];
        }
        return new ResolvedInjectable(injectable, self || this, services);
    };
    Injector.prototype._resolveArrayInjectable = function (injectable, self) {
        return new ResolvedInjectable(injectable[injectable.length - 1], self || this, injectable.slice(0, -1));
    };
    Injector.prototype._resolveStringInjectable = function (injectable, self) {
        var tmp = injectable.split(':');
        self = this.getService(tmp[0], {});
        if (!isFunction(self[tmp[1]])) {
            throw new Error("Invalid serviceMethod injectable " + injectable + ". No method " + tmp[1] + " found in service " + tmp[0]);
        }
        return this._resolveFunctionInjectable(self[tmp[1]], self);
    };
    /**
     *
     */
    Injector.prototype._resolveInjectable = function (injectable, self) {
        if (!isInjectable(injectable)) {
            throw new Error(injectable + " is not a valid injectable");
        }
        else if (isArray(injectable)) {
            return this._resolveArrayInjectable(injectable, self);
        }
        else if (isFunction(injectable)) {
            return this._resolveFunctionInjectable(injectable, self);
        }
        else {
            return this._resolveStringInjectable(injectable, self);
        }
    };
    return Injector;
}());

var Module = /** @class */ (function () {
    /**
     * @param name The name of ne module
     * @param dependencies An array of dependencies modules
     */
    function Module(name, dependencies) {
        this.name = name;
        this.dependencies = dependencies;
        this.services = {};
        this.configHooks = [];
        this.runHooks = [];
    }
    /**
     * @returns The module name
     */
    Module.prototype.getName = function () {
        return this.name;
    };
    /**
     * @param injectable A config hook function
     * @returns The current module
     */
    Module.prototype.config = function (injectable) {
        if (!isInjectable(injectable)) {
            throw new Error("Can't register config injectable " + injectable + " in " + this.getName());
        }
        this.configHooks.push(injectable);
        return this;
    };
    /**
     * @param {Injectable} injectable A run hook function
     * @returns {Module} The current module
     */
    Module.prototype.run = function (injectable) {
        if (!isInjectable(injectable)) {
            throw new Error("Can't register run injectable " + injectable + " in " + this.getName());
        }
        this.runHooks.push(injectable);
        return this;
    };
    /**
     * Register a new service in the module
     * @param serviceName the service name
     * @param serviceClass The service class
     * @returns this
     */
    Module.prototype.service = function (serviceName, serviceClass) {
        if (!isServiceName(serviceName)) {
            throw new Error("Can't register service in " + this.getName() + " with name " + serviceName + ". serviceName must match " + serviceNameRegex);
        }
        if (!isFunction(serviceClass)) {
            throw new Error("Can't register service in " + this.getName() + " with name " + serviceName + ". Invalid serviceClass " + serviceClass);
        }
        this.services[serviceName] = /** @class */ (function () {
            function class_1() {
            }
            class_1.prototype.$get = function ($injector) {
                return $injector.instantiate(serviceClass, { $name: serviceName });
            };
            return class_1;
        }());
        return this;
    };
    /**
     * Register a new service in the module by providing a factory
     * @param serviceName the name of the service
     * @param injectable The function responsible of creating the service instance.
     * @returns this
     */
    Module.prototype.factory = function (serviceName, injectable) {
        if (!isServiceName(serviceName)) {
            throw new Error("Can't register factory in " + this.getName() + " with name " + serviceName + ". serviceName must match " + serviceNameRegex);
        }
        if (!isInjectable(injectable)) {
            throw new Error("Can't register factory in " + this.getName() + " with name " + serviceName + ". Invalid injectable " + injectable);
        }
        this.services[serviceName] = /** @class */ (function () {
            function class_2() {
            }
            class_2.prototype.$get = function ($injector) {
                return $injector.invoke(injectable, $injector, { $name: serviceName });
            };
            return class_2;
        }());
        return this;
    };
    /**
     * Register a new service in the module by providing a provider class
     * @param serviceName The service name
     * @param providerClass A provider constructor
     * @returns this
     */
    Module.prototype.provider = function (serviceName, providerClass) {
        if (!isServiceName(serviceName)) {
            throw new Error("Can't register provider in " + this.getName() + " with name " + serviceName + ". serviceName must match " + serviceNameRegex);
        }
        if (!isFunction(providerClass)) {
            throw new Error("Can't register provider in " + this.getName() + " with name " + serviceName + ". Invalid providerClass " + providerClass);
        }
        this.services[serviceName] = providerClass;
        return this;
    };
    /**
     * Bootstrap the module
     * @return The module injector
     */
    Module.prototype.bootstrap = function () {
        return __awaiter(this, void 0, void 0, function () {
            var modules, $injectors, $injector, i, module_1, j, hook, i, module_2, j, hook;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        modules = [];
                        $injectors = [];
                        $injector = this._bootstrap(modules, $injectors);
                        modules.push(this);
                        $injectors.push($injector);
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(modules.length > i)) return [3 /*break*/, 6];
                        module_1 = modules[i];
                        j = 0;
                        _a.label = 2;
                    case 2:
                        if (!(module_1.configHooks.length > j)) return [3 /*break*/, 5];
                        hook = module_1.configHooks[j];
                        return [4 /*yield*/, $injectors[i].invoke(hook)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        j++;
                        return [3 /*break*/, 2];
                    case 5:
                        i++;
                        return [3 /*break*/, 1];
                    case 6:
                        i = 0;
                        _a.label = 7;
                    case 7:
                        if (!(modules.length > i)) return [3 /*break*/, 12];
                        module_2 = modules[i];
                        j = 0;
                        _a.label = 8;
                    case 8:
                        if (!(module_2.runHooks.length > j)) return [3 /*break*/, 11];
                        hook = module_2.runHooks[j];
                        return [4 /*yield*/, $injectors[i].invoke(hook)];
                    case 9:
                        _a.sent();
                        _a.label = 10;
                    case 10:
                        j++;
                        return [3 /*break*/, 8];
                    case 11:
                        i++;
                        return [3 /*break*/, 7];
                    case 12: return [2 /*return*/, $injector];
                }
            });
        });
    };
    /**
     * Bootstrap the module.
     * @param modules An array of module
     * @param $injectors An array of corresponding injector
     * @returns the newly created injector
     */
    Module.prototype._bootstrap = function (modules, $injectors) {
        var _this = this;
        var $injector = new Injector();
        Object.keys(this.services).forEach(function (serviceName) { return $injector.addProvider(serviceName, _this.services[serviceName]); });
        this.dependencies.forEach(function (dependency) {
            var moduleIndex = modules.indexOf(dependency);
            if (moduleIndex === -1) {
                $injectors.push(dependency._bootstrap(modules, $injectors));
                modules.push(dependency);
                moduleIndex = modules.length - 1;
            }
            $injector.addChild($injectors[moduleIndex]);
        });
        return $injector;
    };
    return Module;
}());

var radis = {
    module: function (moduleName, dependencies) {
        if (dependencies === void 0) { dependencies = []; }
        if (!isModuleName(moduleName)) {
            throw new Error("Invalid module name " + moduleName + ". Module must match " + moduleNameRegex.toString());
        }
        return new Module(moduleName, dependencies);
    }
};

export { radis };
//# sourceMappingURL=radis.es5.js.map
