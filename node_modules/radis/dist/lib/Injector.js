"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var function_arguments_1 = require("function-arguments");
var utils_1 = require("./utils");
var ResolvedInjectable = /** @class */ (function () {
    function ResolvedInjectable(func, self, services) {
        this.func = func;
        this.self = self;
        this.services = services;
    }
    ResolvedInjectable.prototype.invoke = function (injector, locals) {
        var services = this.services.map(function (serviceName) { return injector.getService(serviceName, locals); });
        return this.func.apply(this.self, services);
    };
    return ResolvedInjectable;
}());
/**
 *
 */
var Injector = /** @class */ (function () {
    /**
     *
     */
    function Injector() {
        this.services = {};
    }
    /**
     * This method invoke the given injectable applying right parameters based on their name
     * @param injectable A function to be invoked
     * @param self An object to which the injectable function will be bind to
     * @param locals Additional one-time services that will be injected into the injectable
     * @return The return value of injectable
     */
    Injector.prototype.invoke = function (injectable, self, locals) {
        if (self === void 0) { self = null; }
        if (locals === void 0) { locals = {}; }
        return this._resolveInjectable(injectable, self).invoke(this, locals);
    };
    /**
     * Call new operator on the given injectableClass proving the controller with the right parameters.
     * @info injectableClass.$inject MUST be an array
     * @param injectableClass A injectable class
     * @param locals Additional variables that will be injected
     * @returns A new instance of injectableClass
     */
    Injector.prototype.instantiate = function (injectableClass, locals) {
        var _this = this;
        if (locals === void 0) { locals = {}; }
        var serviceNames = injectableClass['$inject'] || [];
        var services = serviceNames.map(function (serviceName) { return _this.getService(serviceName, locals); });
        return new (injectableClass.bind.apply(injectableClass, [void 0].concat(services)))();
    };
    /**
     * This method lift a classic function to an injectable function.
     * @example
     * let middleware = (service1, req, res, nex) => console.log(service1, req, res, next)
     * let liftedMiddleware = $injector.lift(middleware, ["req", "res", "next"]);
     * app.use(liftedMiddleware) OR  liftedMiddleware(req, res, next(
     * @param injectable The function you want to lift
     * @param self An object to which the injectable function will be bind to
     * @param paramNames the name of the parameter lift will received so they can be injected.
     * @param locals Additional variables that will be injected
     * @return {Function} The lifted function
     */
    Injector.prototype.lift = function (injectable, self, paramNames, locals) {
        var _this = this;
        if (self === void 0) { self = null; }
        if (paramNames === void 0) { paramNames = []; }
        if (locals === void 0) { locals = {}; }
        var cache;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // Merge locals and positional params
            var _locals = Object.assign({}, locals);
            paramNames.forEach(function (name, index) {
                _locals[name] = args[index];
            });
            // If injection was already resolve use cached version.
            if (cache) {
                return cache.invoke(_this, _locals);
            }
            cache = _this._resolveInjectable(injectable, self);
            return cache.invoke(_this, _locals);
        };
    };
    /**
     * @param serviceName The name of the service
     * @param locals Additional variables that will be injected
     * @returns The service instance
     * @throws The service must exist
     * @private
     */
    Injector.prototype.getService = function (serviceName, locals) {
        if (locals === void 0) { locals = {}; }
        if (locals[serviceName] !== undefined) {
            return locals[serviceName];
        }
        if (serviceName === '$injector') {
            return this;
        }
        if (serviceName.endsWith('Provider')) {
            return this._getProvider(serviceName.substr(0, serviceName.length - 'Provider'.length));
        }
        var serviceBag = this.services[serviceName];
        if (!serviceBag) {
            throw new Error("Can't load service with name " + serviceName);
        }
        var provider = this._getProvider(serviceName);
        if (serviceBag.service === undefined) {
            serviceBag.service = this.invoke(provider.$get, provider, { $name: serviceName });
            if (serviceBag.service === undefined) {
                throw new Error("Method $get of " + serviceName + " provider must return a valid service got " + serviceBag.service);
            }
        }
        return serviceBag.service;
    };
    /**
     * Add a child injector
     * @param $injector The child injector
     * @return {Injector} this
     */
    Injector.prototype.addChild = function ($injector) {
        this.services = tslib_1.__assign({}, $injector.services, this.services);
        return this;
    };
    Injector.prototype.addProvider = function (serviceName, providerClass) {
        this.services[serviceName] = { providerClass: providerClass };
        return this;
    };
    /**
     * @param serviceName The service name
     * @returns the provider
     * @private
     */
    Injector.prototype._getProvider = function (serviceName) {
        var serviceBag = this.services[serviceName];
        if (!serviceBag) {
            throw new Error("Can't load service with name " + serviceName);
        }
        if (serviceBag.provider === undefined) {
            serviceBag.provider = new serviceBag.providerClass(this, serviceName);
        }
        return serviceBag.provider;
    };
    Injector.prototype._resolveFunctionInjectable = function (injectable, self) {
        var services = function_arguments_1.default(injectable);
        /*
           * Handle single param arrow function without params with one line return
           * eg: v => true
           * https://github.com/charlike/function-arguments/issues/2
           */
        if (services.length === 1 && services[0] === '') {
            var funcStr = injectable.toString();
            var params = funcStr.replace(/\s/gm, '').split('=>');
            if (params.length < 2)
                throw new Error("Can't parse params for function ${params}");
            services = [params[0]];
        }
        return new ResolvedInjectable(injectable, self || this, services);
    };
    Injector.prototype._resolveArrayInjectable = function (injectable, self) {
        return new ResolvedInjectable(injectable[injectable.length - 1], self || this, injectable.slice(0, -1));
    };
    Injector.prototype._resolveStringInjectable = function (injectable, self) {
        var tmp = injectable.split(':');
        self = this.getService(tmp[0], {});
        if (!utils_1.isFunction(self[tmp[1]])) {
            throw new Error("Invalid serviceMethod injectable " + injectable + ". No method " + tmp[1] + " found in service " + tmp[0]);
        }
        return this._resolveFunctionInjectable(self[tmp[1]], self);
    };
    /**
     *
     */
    Injector.prototype._resolveInjectable = function (injectable, self) {
        if (!utils_1.isInjectable(injectable)) {
            throw new Error(injectable + " is not a valid injectable");
        }
        else if (utils_1.isArray(injectable)) {
            return this._resolveArrayInjectable(injectable, self);
        }
        else if (utils_1.isFunction(injectable)) {
            return this._resolveFunctionInjectable(injectable, self);
        }
        else {
            return this._resolveStringInjectable(injectable, self);
        }
    };
    return Injector;
}());
exports.Injector = Injector;
//# sourceMappingURL=Injector.js.map